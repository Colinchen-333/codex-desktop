下面是一份「美观前端 + Codex 引擎（Codex CLI）」桌面应用的完整 PRD（以 Tauri 桌面端为主），你可以直接拿去开干、拆任务、对齐设计与工程。

注：本 PRD 假设“引擎”使用 Codex CLI（可本地读/改/跑代码） ，并复用其登录缓存（~/.codex/auth.json 或系统凭据存储） 。

⸻

PRD：Codex Desktop（暂定名）

1. 背景与问题定义

1.1 背景

Codex CLI 是 OpenAI 的本地编码代理，能在选定目录内读取、修改并运行代码，且开源、Rust 实现。 
但 CLI 形态天然存在体验短板：会话管理弱、改动不够“可视化可控”、长任务难追踪、错误/重连不可见、对新手不友好。

1.2 目标用户痛点
	•	美观与可读性：CLI 输出拥挤，代码块、diff、工具调用混在一起。
	•	可控变更：用户希望“先看到改了什么，再一键应用/回滚”，而不是盲改。
	•	会话与项目管理：按项目归档、搜索、标注、恢复（resume）不顺手。
	•	稳定性可观测：网络/代理/重连/认证问题在 CLI 里不直观，排障成本高。
	•	安全性：执行命令、写文件需要更严谨的确认与审计。

⸻

2. 产品愿景与定位

2.1 产品一句话

把 Codex CLI 变成一个漂亮、可控、安全、项目态的桌面工作台：
“像 Cursor 那样舒服，但保留 CLI 的强大与可扩展”。

2.2 定位
	•	不是 IDE 的替代品：不与 VS Code/JetBrains 正面对抗；强调“代理工作台 + 变更控制 + 会话/项目态”。
	•	Codex 仍是引擎：本产品提供 UI、流程与安全边界；智能能力来自 Codex CLI/服务端模型。

⸻

3. 目标与非目标

3.1 目标（Must）
	•	美观的聊天式 UI + 可折叠原始终端输出
	•	项目/会话管理（创建、命名、标签、搜索、恢复、归档、导出）
	•	diff-first 变更控制（预览 → 一键应用 → 可回滚）
	•	可控执行（命令执行前确认、显示工作目录、输出日志）
	•	稳定性与排障（网络/代理/登录状态、错误可视化）
	•	跨平台（至少 macOS 优先，Windows/Linux 兼容路线）

3.2 非目标（Not now）
	•	内置完整代码编辑器（最多做文件预览/小改）
	•	自研模型/自研推理引擎
	•	复刻 Codex Web 的云端异步任务系统（可做“本地后台任务”版本，但不是一模一样）

⸻

4. 用户与核心场景

4.1 用户画像
	•	个人开发者/学生：想要更舒服地用 Codex 改项目、写作业、做小产品
	•	效率控：习惯 CLI，但想要更强的会话/变更/审计能力
	•	有代理/VPN 环境用户：对网络稳定性、可观测性敏感

4.2 核心场景（Top）
	1.	在某个 repo 里让 Codex 完成任务：修 bug / 加功能 / 写测试
	2.	看到改动 diff，确认后应用，并一键运行测试
	3.	任务中断/断线后恢复会话继续
	4.	回看历史会话：按项目/标签搜索，复用 prompt 模板
	5.	在代理环境中配置并稳定使用（状态可见、错误可诊断）

⸻

5. 功能需求（MVP → V1）

下面按模块给出“需求 + 关键交互 + 验收点”。

5.1 Onboarding & 引擎接入

需求
	•	首次启动检查：本机是否安装 Codex CLI（可提示安装方式，但不强制自动安装）
	•	支持两种登录：
	•	Sign in with ChatGPT
	•	API Key
Codex CLI 本身支持这两种方式，并会缓存登录信息供下次复用。 

关键交互
	•	欢迎页：选择“使用本机已安装 Codex”或“我稍后安装”
	•	登录页：引导用户完成 Codex 登录（可直接调用 codex login 在内置终端完成）
	•	授权提示：解释本应用会访问本地目录、启动子进程、读取 git 信息

验收
	•	新用户 3 分钟内完成：选项目 → 启动会话 → 看到第一条回复（Time-to-first-response）

⸻

5.2 项目（Workspace/Project）管理

需求
	•	添加项目：选择本地文件夹（支持拖拽）
	•	项目信息展示：
	•	项目名、路径
	•	Git 仓库信息（branch、dirty 状态、最近 commit）
	•	项目级设置：
	•	默认运行目录（cwd）
	•	环境变量（如代理变量）
	•	安全策略（命令执行确认级别）

关键交互
	•	左侧栏：Projects 列表 + 搜索
	•	Project Home：最近会话、常用 prompt、最近改动

验收
	•	任意项目 2 次点击内启动新会话
	•	项目路径失效时给出可修复提示（重新定位/移除）

⸻

5.3 会话（Session）管理

需求
	•	新建会话（绑定项目）
	•	会话重命名、标签、收藏、归档
	•	会话搜索（按关键词/标签/时间/项目）
	•	会话恢复（resume）：
	•	优先调用 Codex 的会话机制（若可用）
	•	若恢复失败，提供 fallback：新会话 + 自动注入摘要/关键上下文

关键交互
	•	Session List：显示标题、最后更新时间、最后一句摘要、标签
	•	右键菜单：Rename / Tag / Export / Delete
	•	一键 Resume：恢复到可继续对话状态

验收
	•	100 条会话仍可流畅滚动、搜索 < 300ms（本地索引后）
	•	恢复失败时不会“静默卡死”，必须给出原因与下一步按钮

⸻

5.4 对话 UI（Chat View）——“美观前端”的核心

需求（MVP）
	•	气泡式对话 + Markdown 渲染
	•	代码块高亮 + 一键复制
	•	引擎输出流式展示（打字机/逐行追加）
	•	可折叠“原始终端输出”（Debug Console）

需求（V1 强化）
	•	工具调用时间线（读文件、写文件、运行命令等动作分组显示）
	•	消息内引用：关联哪些文件被读、哪些命令被跑、哪些 patch 被生成
	•	快捷操作：Retry、Continue、Summarize、Make a plan

关键交互
	•	双视图模式：
	•	Pretty View：卡片化展示（默认）
	•	Raw View：终端输出（折叠，排障时打开）
	•	Command Palette：快速切换项目/会话/执行常用动作

验收
	•	长输出不掉帧（虚拟列表/增量渲染）
	•	每条消息可复制、可引用、可回溯来源（文件/命令/patch）

⸻

5.5 Diff-first 变更控制（产品差异化核心）

需求
	•	当 Codex 产生文件改动：
	•	自动生成 ChangeSet（变更集）
	•	UI 展示：文件列表 + diff 视图
	•	一键操作：
	•	Apply（应用变更）
	•	Revert（回滚到变更前）
	•	Partial apply（可选：按 hunk 选择）
	•	变更审计：
	•	记录是谁触发、何时应用、关联哪条消息

关键交互
	•	每次变更出现时弹出“变更卡片”：
	•	变更摘要（新增/修改/删除文件数）
	•	展开查看 diff
	•	“应用/回滚/暂存”按钮
	•	默认策略：先预览再落盘（除非用户在设置里开启“自动应用”）

验收
	•	应用变更后，git diff 与 UI 一致
	•	回滚必须可靠（至少保证“应用前做快照”）

⸻

5.6 命令执行与安全策略

Codex CLI 能在目录内运行代码/命令。 
我们的 GUI 必须把“执行”变成可控、可审计的行为。

需求
	•	命令执行分级：
	•	仅展示（不会执行）
	•	每次确认后执行（默认）
	•	允许列表自动执行（Allowlist）
	•	执行前展示：
	•	命令内容
	•	cwd（工作目录）
	•	可能影响（写文件/网络访问提示）
	•	执行日志：stdout/stderr、退出码、耗时

关键交互
	•	“Run” 卡片：显示命令 + 风险标签 + Confirm 按钮
	•	可设置全局/项目级 allowlist（如 npm test, pytest, git status）

验收
	•	未确认时绝不执行破坏性命令
	•	每次执行都能在日志里追踪到（可导出）

⸻

5.7 稳定性、网络与代理可视化

需求
	•	状态栏展示：
	•	引擎状态（Running / Stopped / Restarting）
	•	认证状态（已登录/需登录；不展示敏感信息）
	•	网络/代理状态（启用与否）
	•	错误面板：
	•	常见错误分类：认证失败、网络超时、权限不足、项目路径失效
	•	“一键修复”：重新登录 / 打开设置 / 复制诊断信息

关键交互
	•	右上角状态胶囊：点击展开诊断抽屉
	•	“复制诊断信息”按钮（便于发 issue/自查）

验收
	•	引擎异常退出时自动提示 + 可一键重启
	•	用户能在 UI 里知道“现在到底卡在哪”（而不是只看到转圈）

⸻

6. 信息架构（IA）
	•	左侧主导航：
	•	Projects
	•	Sessions
	•	Templates（Prompt 模板）
	•	Settings
	•	主工作区：
	•	Chat（默认）
	•	Changes（diff 面板，可与 Chat 联动）
	•	Console（原始终端/日志，可折叠）
	•	右侧抽屉（可选）：
	•	Files touched（本次会话涉及文件）
	•	Command history
	•	Diagnostics

⸻

7. 端到端关键流程

7.1 新用户首次使用
	1.	启动 → 检测 codex
	2.	引导登录（在内置终端中完成 codex login）
	3.	选择项目目录
	4.	新建会话 → 输入需求
	5.	输出生成 → 产生 diff → 预览 → Apply → Run tests

7.2 恢复会话
	1.	Sessions 列表 → 选中 → Resume
	2.	恢复成功：继续对话
	3.	恢复失败：显示原因 → “新会话继续（注入摘要）”

7.3 安全执行
	1.	Codex 提议跑命令
	2.	UI 显示 Run 卡片 → 用户确认
	3.	执行 → 展示日志 → 如果失败提供“把日志发回 Codex 继续排障”按钮

⸻

8. 技术架构（Tauri + Codex 引擎）

8.1 总体架构
	•	前端（WebView）：React/Solid + Tailwind（你也可延用 codexsm 的技术栈）
	•	Tauri Rust 后端：
	•	进程管理：启动/停止/重启 codex
	•	PTY（伪终端）：保证 codex 作为“真终端交互程序”运行稳定
	•	事件总线：流式输出 → 前端
	•	文件系统与 git：diff、快照、回滚、状态读取
	•	本地数据库：SQLite（项目/会话索引、变更记录、模板）

8.2 PTY 方案
	•	优先用现成的 Tauri v2 PTY 插件（生态里已有实现与 crate 版本） 
	•	若生态不满足：自行集成 portable-pty（跨平台复杂度更高）

8.3 与 Codex CLI 的交互方式
	•	MVP：把 codex 当作子进程（PTY 中运行），读写 stdin/stdout
	•	会话持久化：
	•	我们自己存“UI 级会话结构”（消息、标签、变更集）
	•	同时尽量复用 codex 自己的认证缓存机制（不重复造轮子） 

8.4 权限与安全（Tauri 能力声明）
	•	文件访问：仅限用户选定的项目目录（sandbox 思想）
	•	进程执行：只允许启动 codex 与 allowlist 命令（可配置）
	•	网络：由 codex/系统代理决定；UI 层只做状态与配置

⸻

9. 数据与存储设计
	•	App 数据目录（跨平台）保存：
	•	projects（id、path、displayName、最近打开时间）
	•	sessions（id、projectId、title、tags、createdAt、lastActiveAt）
	•	messages（role、content、attachments、timestamps）
	•	changesets（files、diff、applyStatus、snapshotRef）
	•	command_runs（cmd、cwd、exitCode、stdout/stderr、duration）
	•	templates（prompt 模板、变量、快捷键）
	•	快照策略：
	•	Apply 前创建 snapshot（git repo 用 git stash/git worktree/patch-based snapshot；非 git 目录用本地增量备份）

⸻

10. 设计规范（美观前端）

10.1 视觉风格
	•	“陶瓷白 + 黑色点缀”，高留白、圆角卡片、柔和阴影
	•	信息层级清晰：标题/摘要/细节（折叠）
	•	diff 卡片是第一优先级视觉模块

10.2 交互原则
	•	默认不做破坏性动作（先预览再落盘）
	•	错误不“藏起来”：每个失败都给出下一步按钮
	•	键盘优先：Cmd/Ctrl+K 呼出命令面板；Cmd/Ctrl+Enter 发送；Esc 折叠 Console

⸻

11. 质量指标（Metrics）
	•	激活：首次启动到首次回复耗时（TTFR）
	•	成功率：会话恢复成功率、Apply 成功率、命令执行成功率
	•	稳定性：引擎崩溃率、重启恢复率
	•	体验：每会话平均完成任务数、用户主动回滚率（过高说明可控性不足或提示不清）
	•	留存：7 日内再次使用率（按项目维度）

⸻

12. 风险与应对
	•	Codex CLI 行为变更：通过“适配层 + feature flags”隔离；引擎版本检测
	•	Windows PTY 复杂：先保证 macOS 体验最佳，Windows 走渐进增强
	•	安全风险：默认每次命令确认；高危命令强制二次确认；完整审计日志
	•	许可证风险（如果你基于 GPL 项目二开）：若你未来要闭源商业化，需尽早规划“参考思路但重写代码”路线（这一点在工程决策上很关键）

⸻

13. 里程碑（按阶段，不给时间承诺）

Phase 0（MVP）
	•	Projects + Sessions 列表
	•	Chat 视图（Markdown + 代码块）
	•	PTY 启动 codex，流式输出
	•	原始 Console 折叠面板
	•	基础设置（cwd、环境变量）

Phase 1（可控变更）
	•	ChangeSet 生成与 diff 预览
	•	Apply / Revert（快照机制）
	•	命令执行确认与日志

Phase 2（产品化）
	•	搜索/标签/模板
	•	诊断中心（代理/认证/错误分类）
	•	导出（会话/日志/变更记录）

⸻

14. MVP 验收清单（最硬的“可用”标准）
	•	能在 App 内完成：选项目 → 启动 codex → 对话 → 产生改动 → 预览 diff → 应用 → 运行测试 → 看日志
	•	引擎断开/退出后：UI 不假死，能提示并一键恢复
	•	未确认的命令不会被执行
	•	所有落盘变更可回滚（至少到应用前快照）

⸻

如果你希望我把这份 PRD 进一步“工程化”成任务分解（Backlog），我可以直接按 Tauri 结构拆成：
	•	src-tauri：PTY/进程管理/事件/DB/快照
	•	src：Chat/Changes/Console/Projects/Sessions/Settings 组件树
并给出每个模块的接口（Rust command + event payload）与状态机。你说一句：你准备前端用 Solid（沿用 codexsm） 还是 React？